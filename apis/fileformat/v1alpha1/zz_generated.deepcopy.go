//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Format) DeepCopyInto(out *Format) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Format.
func (in *Format) DeepCopy() *Format {
	if in == nil {
		return nil
	}
	out := new(Format)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Format) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FormatInitParameters) DeepCopyInto(out *FormatInitParameters) {
	*out = *in
	if in.AllowDuplicate != nil {
		in, out := &in.AllowDuplicate, &out.AllowDuplicate
		*out = new(bool)
		**out = **in
	}
	if in.BinaryAsText != nil {
		in, out := &in.BinaryAsText, &out.BinaryAsText
		*out = new(bool)
		**out = **in
	}
	if in.BinaryFormat != nil {
		in, out := &in.BinaryFormat, &out.BinaryFormat
		*out = new(string)
		**out = **in
	}
	if in.Comment != nil {
		in, out := &in.Comment, &out.Comment
		*out = new(string)
		**out = **in
	}
	if in.Compression != nil {
		in, out := &in.Compression, &out.Compression
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = new(string)
		**out = **in
	}
	if in.DateFormat != nil {
		in, out := &in.DateFormat, &out.DateFormat
		*out = new(string)
		**out = **in
	}
	if in.DisableAutoConvert != nil {
		in, out := &in.DisableAutoConvert, &out.DisableAutoConvert
		*out = new(bool)
		**out = **in
	}
	if in.DisableSnowflakeData != nil {
		in, out := &in.DisableSnowflakeData, &out.DisableSnowflakeData
		*out = new(bool)
		**out = **in
	}
	if in.EmptyFieldAsNull != nil {
		in, out := &in.EmptyFieldAsNull, &out.EmptyFieldAsNull
		*out = new(bool)
		**out = **in
	}
	if in.EnableOctal != nil {
		in, out := &in.EnableOctal, &out.EnableOctal
		*out = new(bool)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.ErrorOnColumnCountMismatch != nil {
		in, out := &in.ErrorOnColumnCountMismatch, &out.ErrorOnColumnCountMismatch
		*out = new(bool)
		**out = **in
	}
	if in.Escape != nil {
		in, out := &in.Escape, &out.Escape
		*out = new(string)
		**out = **in
	}
	if in.EscapeUnenclosedField != nil {
		in, out := &in.EscapeUnenclosedField, &out.EscapeUnenclosedField
		*out = new(string)
		**out = **in
	}
	if in.FieldDelimiter != nil {
		in, out := &in.FieldDelimiter, &out.FieldDelimiter
		*out = new(string)
		**out = **in
	}
	if in.FieldOptionallyEnclosedBy != nil {
		in, out := &in.FieldOptionallyEnclosedBy, &out.FieldOptionallyEnclosedBy
		*out = new(string)
		**out = **in
	}
	if in.FileExtension != nil {
		in, out := &in.FileExtension, &out.FileExtension
		*out = new(string)
		**out = **in
	}
	if in.FormatType != nil {
		in, out := &in.FormatType, &out.FormatType
		*out = new(string)
		**out = **in
	}
	if in.IgnoreUTF8Errors != nil {
		in, out := &in.IgnoreUTF8Errors, &out.IgnoreUTF8Errors
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NullIf != nil {
		in, out := &in.NullIf, &out.NullIf
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ParseHeader != nil {
		in, out := &in.ParseHeader, &out.ParseHeader
		*out = new(bool)
		**out = **in
	}
	if in.PreserveSpace != nil {
		in, out := &in.PreserveSpace, &out.PreserveSpace
		*out = new(bool)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.ReplaceInvalidCharacters != nil {
		in, out := &in.ReplaceInvalidCharacters, &out.ReplaceInvalidCharacters
		*out = new(bool)
		**out = **in
	}
	if in.Schema != nil {
		in, out := &in.Schema, &out.Schema
		*out = new(string)
		**out = **in
	}
	if in.SkipBlankLines != nil {
		in, out := &in.SkipBlankLines, &out.SkipBlankLines
		*out = new(bool)
		**out = **in
	}
	if in.SkipByteOrderMark != nil {
		in, out := &in.SkipByteOrderMark, &out.SkipByteOrderMark
		*out = new(bool)
		**out = **in
	}
	if in.SkipHeader != nil {
		in, out := &in.SkipHeader, &out.SkipHeader
		*out = new(float64)
		**out = **in
	}
	if in.StripNullValues != nil {
		in, out := &in.StripNullValues, &out.StripNullValues
		*out = new(bool)
		**out = **in
	}
	if in.StripOuterArray != nil {
		in, out := &in.StripOuterArray, &out.StripOuterArray
		*out = new(bool)
		**out = **in
	}
	if in.StripOuterElement != nil {
		in, out := &in.StripOuterElement, &out.StripOuterElement
		*out = new(bool)
		**out = **in
	}
	if in.TimeFormat != nil {
		in, out := &in.TimeFormat, &out.TimeFormat
		*out = new(string)
		**out = **in
	}
	if in.TimestampFormat != nil {
		in, out := &in.TimestampFormat, &out.TimestampFormat
		*out = new(string)
		**out = **in
	}
	if in.TrimSpace != nil {
		in, out := &in.TrimSpace, &out.TrimSpace
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FormatInitParameters.
func (in *FormatInitParameters) DeepCopy() *FormatInitParameters {
	if in == nil {
		return nil
	}
	out := new(FormatInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FormatList) DeepCopyInto(out *FormatList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Format, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FormatList.
func (in *FormatList) DeepCopy() *FormatList {
	if in == nil {
		return nil
	}
	out := new(FormatList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *FormatList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FormatObservation) DeepCopyInto(out *FormatObservation) {
	*out = *in
	if in.AllowDuplicate != nil {
		in, out := &in.AllowDuplicate, &out.AllowDuplicate
		*out = new(bool)
		**out = **in
	}
	if in.BinaryAsText != nil {
		in, out := &in.BinaryAsText, &out.BinaryAsText
		*out = new(bool)
		**out = **in
	}
	if in.BinaryFormat != nil {
		in, out := &in.BinaryFormat, &out.BinaryFormat
		*out = new(string)
		**out = **in
	}
	if in.Comment != nil {
		in, out := &in.Comment, &out.Comment
		*out = new(string)
		**out = **in
	}
	if in.Compression != nil {
		in, out := &in.Compression, &out.Compression
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = new(string)
		**out = **in
	}
	if in.DateFormat != nil {
		in, out := &in.DateFormat, &out.DateFormat
		*out = new(string)
		**out = **in
	}
	if in.DisableAutoConvert != nil {
		in, out := &in.DisableAutoConvert, &out.DisableAutoConvert
		*out = new(bool)
		**out = **in
	}
	if in.DisableSnowflakeData != nil {
		in, out := &in.DisableSnowflakeData, &out.DisableSnowflakeData
		*out = new(bool)
		**out = **in
	}
	if in.EmptyFieldAsNull != nil {
		in, out := &in.EmptyFieldAsNull, &out.EmptyFieldAsNull
		*out = new(bool)
		**out = **in
	}
	if in.EnableOctal != nil {
		in, out := &in.EnableOctal, &out.EnableOctal
		*out = new(bool)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.ErrorOnColumnCountMismatch != nil {
		in, out := &in.ErrorOnColumnCountMismatch, &out.ErrorOnColumnCountMismatch
		*out = new(bool)
		**out = **in
	}
	if in.Escape != nil {
		in, out := &in.Escape, &out.Escape
		*out = new(string)
		**out = **in
	}
	if in.EscapeUnenclosedField != nil {
		in, out := &in.EscapeUnenclosedField, &out.EscapeUnenclosedField
		*out = new(string)
		**out = **in
	}
	if in.FieldDelimiter != nil {
		in, out := &in.FieldDelimiter, &out.FieldDelimiter
		*out = new(string)
		**out = **in
	}
	if in.FieldOptionallyEnclosedBy != nil {
		in, out := &in.FieldOptionallyEnclosedBy, &out.FieldOptionallyEnclosedBy
		*out = new(string)
		**out = **in
	}
	if in.FileExtension != nil {
		in, out := &in.FileExtension, &out.FileExtension
		*out = new(string)
		**out = **in
	}
	if in.FormatType != nil {
		in, out := &in.FormatType, &out.FormatType
		*out = new(string)
		**out = **in
	}
	if in.FullyQualifiedName != nil {
		in, out := &in.FullyQualifiedName, &out.FullyQualifiedName
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IgnoreUTF8Errors != nil {
		in, out := &in.IgnoreUTF8Errors, &out.IgnoreUTF8Errors
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NullIf != nil {
		in, out := &in.NullIf, &out.NullIf
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ParseHeader != nil {
		in, out := &in.ParseHeader, &out.ParseHeader
		*out = new(bool)
		**out = **in
	}
	if in.PreserveSpace != nil {
		in, out := &in.PreserveSpace, &out.PreserveSpace
		*out = new(bool)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.ReplaceInvalidCharacters != nil {
		in, out := &in.ReplaceInvalidCharacters, &out.ReplaceInvalidCharacters
		*out = new(bool)
		**out = **in
	}
	if in.Schema != nil {
		in, out := &in.Schema, &out.Schema
		*out = new(string)
		**out = **in
	}
	if in.SkipBlankLines != nil {
		in, out := &in.SkipBlankLines, &out.SkipBlankLines
		*out = new(bool)
		**out = **in
	}
	if in.SkipByteOrderMark != nil {
		in, out := &in.SkipByteOrderMark, &out.SkipByteOrderMark
		*out = new(bool)
		**out = **in
	}
	if in.SkipHeader != nil {
		in, out := &in.SkipHeader, &out.SkipHeader
		*out = new(float64)
		**out = **in
	}
	if in.StripNullValues != nil {
		in, out := &in.StripNullValues, &out.StripNullValues
		*out = new(bool)
		**out = **in
	}
	if in.StripOuterArray != nil {
		in, out := &in.StripOuterArray, &out.StripOuterArray
		*out = new(bool)
		**out = **in
	}
	if in.StripOuterElement != nil {
		in, out := &in.StripOuterElement, &out.StripOuterElement
		*out = new(bool)
		**out = **in
	}
	if in.TimeFormat != nil {
		in, out := &in.TimeFormat, &out.TimeFormat
		*out = new(string)
		**out = **in
	}
	if in.TimestampFormat != nil {
		in, out := &in.TimestampFormat, &out.TimestampFormat
		*out = new(string)
		**out = **in
	}
	if in.TrimSpace != nil {
		in, out := &in.TrimSpace, &out.TrimSpace
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FormatObservation.
func (in *FormatObservation) DeepCopy() *FormatObservation {
	if in == nil {
		return nil
	}
	out := new(FormatObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FormatParameters) DeepCopyInto(out *FormatParameters) {
	*out = *in
	if in.AllowDuplicate != nil {
		in, out := &in.AllowDuplicate, &out.AllowDuplicate
		*out = new(bool)
		**out = **in
	}
	if in.BinaryAsText != nil {
		in, out := &in.BinaryAsText, &out.BinaryAsText
		*out = new(bool)
		**out = **in
	}
	if in.BinaryFormat != nil {
		in, out := &in.BinaryFormat, &out.BinaryFormat
		*out = new(string)
		**out = **in
	}
	if in.Comment != nil {
		in, out := &in.Comment, &out.Comment
		*out = new(string)
		**out = **in
	}
	if in.Compression != nil {
		in, out := &in.Compression, &out.Compression
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = new(string)
		**out = **in
	}
	if in.DateFormat != nil {
		in, out := &in.DateFormat, &out.DateFormat
		*out = new(string)
		**out = **in
	}
	if in.DisableAutoConvert != nil {
		in, out := &in.DisableAutoConvert, &out.DisableAutoConvert
		*out = new(bool)
		**out = **in
	}
	if in.DisableSnowflakeData != nil {
		in, out := &in.DisableSnowflakeData, &out.DisableSnowflakeData
		*out = new(bool)
		**out = **in
	}
	if in.EmptyFieldAsNull != nil {
		in, out := &in.EmptyFieldAsNull, &out.EmptyFieldAsNull
		*out = new(bool)
		**out = **in
	}
	if in.EnableOctal != nil {
		in, out := &in.EnableOctal, &out.EnableOctal
		*out = new(bool)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.ErrorOnColumnCountMismatch != nil {
		in, out := &in.ErrorOnColumnCountMismatch, &out.ErrorOnColumnCountMismatch
		*out = new(bool)
		**out = **in
	}
	if in.Escape != nil {
		in, out := &in.Escape, &out.Escape
		*out = new(string)
		**out = **in
	}
	if in.EscapeUnenclosedField != nil {
		in, out := &in.EscapeUnenclosedField, &out.EscapeUnenclosedField
		*out = new(string)
		**out = **in
	}
	if in.FieldDelimiter != nil {
		in, out := &in.FieldDelimiter, &out.FieldDelimiter
		*out = new(string)
		**out = **in
	}
	if in.FieldOptionallyEnclosedBy != nil {
		in, out := &in.FieldOptionallyEnclosedBy, &out.FieldOptionallyEnclosedBy
		*out = new(string)
		**out = **in
	}
	if in.FileExtension != nil {
		in, out := &in.FileExtension, &out.FileExtension
		*out = new(string)
		**out = **in
	}
	if in.FormatType != nil {
		in, out := &in.FormatType, &out.FormatType
		*out = new(string)
		**out = **in
	}
	if in.IgnoreUTF8Errors != nil {
		in, out := &in.IgnoreUTF8Errors, &out.IgnoreUTF8Errors
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NullIf != nil {
		in, out := &in.NullIf, &out.NullIf
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ParseHeader != nil {
		in, out := &in.ParseHeader, &out.ParseHeader
		*out = new(bool)
		**out = **in
	}
	if in.PreserveSpace != nil {
		in, out := &in.PreserveSpace, &out.PreserveSpace
		*out = new(bool)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.ReplaceInvalidCharacters != nil {
		in, out := &in.ReplaceInvalidCharacters, &out.ReplaceInvalidCharacters
		*out = new(bool)
		**out = **in
	}
	if in.Schema != nil {
		in, out := &in.Schema, &out.Schema
		*out = new(string)
		**out = **in
	}
	if in.SkipBlankLines != nil {
		in, out := &in.SkipBlankLines, &out.SkipBlankLines
		*out = new(bool)
		**out = **in
	}
	if in.SkipByteOrderMark != nil {
		in, out := &in.SkipByteOrderMark, &out.SkipByteOrderMark
		*out = new(bool)
		**out = **in
	}
	if in.SkipHeader != nil {
		in, out := &in.SkipHeader, &out.SkipHeader
		*out = new(float64)
		**out = **in
	}
	if in.StripNullValues != nil {
		in, out := &in.StripNullValues, &out.StripNullValues
		*out = new(bool)
		**out = **in
	}
	if in.StripOuterArray != nil {
		in, out := &in.StripOuterArray, &out.StripOuterArray
		*out = new(bool)
		**out = **in
	}
	if in.StripOuterElement != nil {
		in, out := &in.StripOuterElement, &out.StripOuterElement
		*out = new(bool)
		**out = **in
	}
	if in.TimeFormat != nil {
		in, out := &in.TimeFormat, &out.TimeFormat
		*out = new(string)
		**out = **in
	}
	if in.TimestampFormat != nil {
		in, out := &in.TimestampFormat, &out.TimestampFormat
		*out = new(string)
		**out = **in
	}
	if in.TrimSpace != nil {
		in, out := &in.TrimSpace, &out.TrimSpace
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FormatParameters.
func (in *FormatParameters) DeepCopy() *FormatParameters {
	if in == nil {
		return nil
	}
	out := new(FormatParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FormatSpec) DeepCopyInto(out *FormatSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FormatSpec.
func (in *FormatSpec) DeepCopy() *FormatSpec {
	if in == nil {
		return nil
	}
	out := new(FormatSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FormatStatus) DeepCopyInto(out *FormatStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FormatStatus.
func (in *FormatStatus) DeepCopy() *FormatStatus {
	if in == nil {
		return nil
	}
	out := new(FormatStatus)
	in.DeepCopyInto(out)
	return out
}
